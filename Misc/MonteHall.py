
import random



""" describes and executes the steps to recreate the Mote Hall Problem """
class MonteHall(object):



	def __init__(self):

		# keep track of doors guessed or seen
		self.guessed = []

		# the potential outcomes of a game
		self.outcomes = ["Goat1", "Goat2", "Car"]

		# shuffle the outcomes for each instance
		random.shuffle(self.outcomes)

		# assign the values to a doors
		self.door1 = self.outcomes[0]
		self.door2 = self.outcomes[1]
		self.door3 = self.outcomes[2]

		# convinient way to reffer to all the doors - could also use a dict
		self.allDoors = [self.door1, self.door2, self.door3]

		# which door got opened after guess 1?
		self.openedDoor = None

		# what is our final guess?
		self.finalAnswer = None


	""" make our first selecton """
	def guess(self, doorChoice):

		# note the guess
		self.guessed.append(doorChoice)

		# return the value stored in that door
		return getattr(self, doorChoice)


	""" open a door after the first guess before offering chance to switch """
	def openDoor(self):
		# ~ NOTE: this is the intervention! They always open a door in front of a goat!
		# ~ If they opened a truly random door, people's intuition about the problem
		# ~ would be correct. However, they avoid revealing the car here, and this is
		# ~ where things get weird: they've altered the way the data are generated by
		# ~ manually selecting a door with a goat behind it
		self.openedDoor = [d for d in self.allDoors if d not in self.guessed and d != "Car"][0]

		# count the second empty door as "guessed" because we know what it is
		self.guessed.append(self.openedDoor)


	""" switch to the only opened door remaining, or keep initial guess """
	def changeDoor(self, change):
		if change == True:
			# get the only doors we haven't guess and isn't opened
			self.finalAnswer = [d for d in self.allDoors if \
				d not in self.guessed and d != self.openDoor][0]
		else:
			# or stick with the first guess
			self.finalAnswer = getattr(self, self.guessed[0])


	""" runs desired number of instances of a game, returns list of results """
	def runSimulations(doorToGuess, numberOfGames, switchDoors):
		gamesRun = []
		# execute the steps of a game
		for i in range(numberOfGames):
			game = MonteHall()
			game.guess(doorToGuess)
			game.openDoor()
			game.changeDoor(switchDoors)
			gamesRun.append(game.finalAnswer)
		return gamesRun





############| ~ main ~ |############

# get 5000 runs of the game, with and without switching
switchResults = MonteHall.runSimulations(
	doorToGuess = "door1", numberOfGames = 5000, switchDoors = True
)
nonSwitchResults = MonteHall.runSimulations(
	doorToGuess = "door1", numberOfGames = 5000, switchDoors = False
)

# get number of cars for each set of simulations
switchWins = [g for g in switchResults if g == "Car"]
nonSwitchWins = [g for g in nonSwitchResults if g == "Car"]

# find percent
print("With switching:", len(switchWins)/len(switchResults))
print("Without switching:", len(nonSwitchWins)/len(nonSwitchResults))
